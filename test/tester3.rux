# class Person
#   # `@dynamic` annotation is to tell steep that
#   # the `name` and `contacts` methods are defined without def syntax.
#   # (Steep can skip checking if the methods are implemented.)

#   # @dynamic name, contacts
#   public attr_reader @name: String
#   public attr_reader @contacts: Array[Email | Phone]

#   def initialize(name: String) -> untyped
#     @name = name
#     @contacts = []
#   end

#   def guess_country -> (String | nil)
#     contacts.map do |contact|
#       # With case expression, simple type-case is implemented.
#       # `contact` has type of `Phone | Email` but in the `when` clause, contact has type of `Phone`.
#       case contact
#       when Phone
#         contact.country
#       end
#     end.compact.first
#   end
# end

# class Email
#   # @dynamic address
#   attr_reader @address: String

#   def initialize(address: String) -> untyped
#     @address = address
#   end

#   def ==(other: untyped) -> bool
#     # `other` has type of `untyped`, which means type checking is skipped.
#     # No type errors can be detected in this method.
#     other.is_a?(self.class) && other.address == address
#   end

#   def hash -> Numeric
#     self.class.hash ^ address.hash
#   end
# end

class Phone
  # @dynamic country, number
  attr_reader :country, :number

  def initialize(country: String, number: String)
    @country = country
    @number = number
  end

  def ==(other: untyped) -> bool
    # You cannot use `case` for type case because `other` has type of `untyped`, not a union type.
    # You have to explicitly declare the type of `other` in `if` expression.

    if other.is_a?(Phone)
      # @type var other: Phone
      other.country == country && other.number == number
    end
  end

  def hash -> Numeric
    self.class.hash ^ country.hash ^ number.hash
  end
end
